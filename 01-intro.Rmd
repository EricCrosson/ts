```{r, echo=FALSE, include=FALSE}
library(astsa)
library(mgcv)
library(simts)
library(imudata)
```

```{r introduction_code, echo = FALSE, cache = FALSE, warning=FALSE, message=FALSE}
library(astsa)
library(imudata)
library(simts)

# Function computes direction random walk moves
RW2dimension = function(steps = 100, probs = c(0.25, 0.5, 0.75),
                        couleur = "blue4", xlab = "X-position",
                        ylab = "Y-position", main = NULL, pt_col = NULL,
                        pt_pch = 16, pt.cex = 2, leg_pos = NULL){
  
  # Title
  if (is.null(main)){
    main = paste("Simulated 2D RW with", steps, "steps", sep = " ")
  }
  
  # Points colors
  if (is.null(pt_col)){
    hues = seq(15, 375, length = 3)
    pt_col = hcl(h = hues, l = 65, c = 100)[1:2]
  }
  
  # Initial matrix
  step_direction = matrix(0, steps+1, 2)

  # Start random walk
  for (i in seq(2, steps+1)){
    # Draw a random number from U(0,1)
    rn = runif(1)

    # Go right if rn \in [0,prob[1])
    if (rn < probs[1]) {step_direction[i,1] = 1}

    # Go left if rn \in [probs[1], probs[2])
    if (rn >= probs[1] && rn < probs[2]) {step_direction[i,1] = -1}

    # Go forward if rn \in [probs[2], probs[3])
    if (rn >= probs[2] && rn < probs[3]) {step_direction[i,2] = 1}

    # Go backward if rn \in [probs[3],1]
    if (rn >= probs[3]) {step_direction[i,2] = -1}
  }

  # Cumulative steps
  position = data.frame(x = cumsum(step_direction[, 1]), 
                        y = cumsum(step_direction[, 2]))
  
  par(mar = c(5.1, 5.1, 1, 2.1))

  # Main plot
  plot(NA, xlim = range(position[,1]), ylim = range(range(position[,2])), 
       xlab = xlab, ylab = ylab, xaxt = 'n', 
       yaxt = 'n', bty = "n", ann = FALSE)
  win_dim = par("usr")

  par(new = TRUE)
  plot(NA, xlim = range(position[,1]), ylim = c(win_dim[3], win_dim[4] + 0.09*(win_dim[4] - win_dim[3])),
       xlab = xlab, ylab = ylab, xaxt = 'n', yaxt = 'n', bty = "n")
  win_dim = par("usr")

  # Add grid
  grid(NULL, NULL, lty = 1, col = "grey95")

  # Add title
  x_vec = c(win_dim[1], win_dim[2], win_dim[2], win_dim[1])
  y_vec = c(win_dim[4], win_dim[4],
            win_dim[4] - 0.09*(win_dim[4] - win_dim[3]),
            win_dim[4] - 0.09*(win_dim[4] - win_dim[3]))
  polygon(x_vec, y_vec, col = "grey95", border = NA)
  text(x = mean(c(win_dim[1], win_dim[2])), y = (win_dim[4] - 0.09/2*(win_dim[4] - win_dim[3])), main)

  # Add axes and box
  lines(x_vec[1:2], rep((win_dim[4] - 0.09*(win_dim[4] - win_dim[3])),2), col = 1)
  box()
  axis(1, padj = 0.3)
  y_axis = axis(2, labels = FALSE, tick = FALSE)
  y_axis = y_axis[y_axis < (win_dim[4] - 0.09*(win_dim[4] - win_dim[3]))]
  axis(2, padj = -0.2, at = y_axis)

  # Add trajectory
  lines(position, type = "l", col = couleur, pch = 16)
  
  # Start and end points
  points(c(0,position[steps+1,1]), c(0,position[steps+1,2]), cex = pt.cex,
         col = pt_col, pch = pt_pch)
  
  # Legend
  if (is.null(leg_pos)){
    leg_pos = c(min(position[,1]), max(position[,2]))
  }
  legend(leg_pos[1], leg_pos[2], c("Start","End"), 
         col = pt_col, pch = pt_pch, pt.cex = pt.cex, bty = "n")
}
```

# Basic Elements of Time Series 

We can start the discussion on the basic elements of time series by using a practical example from real data made available through the R software. The data represent the global mean landâ€“ocean temperature shifts from 1880 to 2015 (with base index being the average temperatures from 1951 to 1980) and this time series is represented in the plot below.

```{r, echo=FALSE}
plot(globtemp, type="l", ylab="Global Temperature Deviations")
```

These data have been used as a support in favour of the argument that the global temperatures are increasing and that global warming has occured over the last half of the twentieth century. The first approach that one would take is to try and measure the average increase by fitting a (linear) model and testing if the (positive) slope is significant. In order to do so, we would require the residuals from the fitted model to independently and identically distributed (iid). Let us fit a model with the years (time) as explanatory variable and check the residuals from this fit.

```{r, echo=FALSE}
time <- 1:length(globtemp)
fit <- gam(globtemp ~ s(time))
resids <- resid(fit)

layout(matrix(c(1, 2, 3, 4), 2, 2, byrow = T))
plot(resids, type="l", ylab="Global Temperature Residuals")
plot(resids, ylab="Global Temperature Residuals")
hist(resids)
qqnorm(resids)
qqline(resids)
```

It can be seen from the upper left plot that the trend appears to be removed and, if looking at the residuals as one would usually do in a (linear) regression framework, the residual plots seem to suggest that the modelling has done a relatively good job since no particular pattern seems to emerge and their distribution is quite close to being Gaussian.

However, is it possible to conclude from the plots that the data are *iid*? More specifically, can we assume that the residuals are independent? This is a fundamental question in order for inference procedures to be carried out in an appropriate manner and to limit false conclusions. Let us provide an example through a simulated data set where we know that there is an upward trend through time (i.e. the slope $\beta = 0.01$) and our goal would be to show that this trend exists. Considering this, we simulate two cases where, in the first, the residuals are actually Gaussian iid while, in the second, the residuals are Gaussian but are dependent over time. The first case is shown below.

```{r}
set.seed(9)

# Simulate time series with iid residuals
y.ind <- cumsum(rep(0.01, 100)) + rnorm(100)

# Simulate time series with dependent residuals
y.dep <- cumsum(rep(0.01, 100)) + arima.sim(n = 100, list(ar = c(0.8897, -0.4858)))

# Define explanatory variable (time)
time <- 1:100

# Fit a linear model to estimate the slope (for the iid setting)
fit.ind <- lm(y.ind ~ time)
summary(fit.ind)

# Fit a linear model to estimate the slope (for the dependent setting)
fit.dep <- lm(y.dep ~ time)
summary(fit.dep)
```

As can be seen, the estimated slope ($\approx$ `r round(fit.ind$coefficients[2], 3)`) is close to the true slope (0.01) and is significant (i.e. the p-value is smaller than the common rejection level 0.05). Hence, from this inference procedure we can conclude that the slope is significant and is roughly equal to 0.01 (which corresponds to the truth). However, let us explore the same analysis when the residuals are not independent.

```{r}
set.seed(9)

# Simulate time series with dependent residuals
y.dep <- cumsum(rep(0.01, 100)) + arima.sim(n = 100, list(ar = c(0.8897, -0.4858)))

# Define explanatory variable (time)
time <- 1:100

# Fit a linear model to estimate the slope (for the dependent setting)
fit.dep <- lm(y.dep ~ time)
summary(fit.dep)
```

In this case we can observe that the p-value is greater than 0.05 and consequently the slope does not appear to be significant (although it is in reality). Therefore, the inference procedures can be misleading when not taking into account other possible significant variables or, in this case, forms of dependence that can hide true underlying effects.

The above examples therefore highlight how the approach to analysing time series does not only rely on finding an appropriate model that describes the evolution of a variable as a function of time (which is deterministic). Indeed, the main focus of time series analysis consists in modelling the dependence structure that describes how random variables impact each other as a function of time. In other words, a time series is a collection of random variables whose interaction and dependence structure is indexed by time.

## The Wold Decomposition

The previous discussion highlighted how a time series can be decomposed into a deterministic component and a random component. Leaving aside technical rigour, this characteristic of time series was put forward in Wold's Decomposition Theorem who postulated that a time series $(Y_t)$ (where $t = 1,...,n$ represents the time index) can be very generically represented as follows:

$$Y_t = D_t + W_t,$$

where $D_t$ represents the deterministic part (or *signal*) that can be modelled through the standard modelling techniques (e.g. linear regression) and $W_t$ that, restricting ourselves to a general class of processes, represents the random part (*noise*) that requires the analytical and modelling approaches that will be tackled in this book.
 
Typically, we have $\mathbb{E}[Y_t] \neq 0$ while $\mathbb{E}[W_t] = 0$ (although we may have
$\mathbb{E}[W_t | W_{t-1}, ..., W_1] \neq 0$). Such models impose some parametric
structure which represents a convenient and flexible way of studying time series
as well as a means to evaluate *future* values of the series through forecasting.
As we will see, predicting future values is one of the main aspects of time
series analysis. However, making predictions is often a daunting task or as
famously stated by Nils Bohr:

> 
> "*Prediction is very difficult, especially about the future.*"
>

There are plenty of examples of predictions that turned out to be completely
erroneous. For example, three days before the 1929 crash, Irving Fisher,
Professor of Economics at Yale University, famously predicted:

>
> "*Stock prices have reached what looks like a permanently high plateau*". 
>

Another example is given by Thomas Watson, president of IBM, who said in 1943:

>
> "*I think there is a world market for maybe five computers.*"
>

Let us now briefly discuss the two components of a time series.

### The deterministic component (Signal)

Before shifting our focus to the random component of time series, we will first just briefly underline the main features that should be taken into account for the deterministic component. The first feature that should be analysed is the *trend* that characterises the time series, more specifically the behaviour of the variable of interest as a specific function of time (as the global temperature time series seen earlier). Let us consider another example of time series based on real data, i.e. the quarterly earnings of Johnson & Johnson between 1960 and 1980 represented below.

```{r, echo=FALSE}
plot(jj, type="l", ylab="Quarterly Earnings per Share")
```

As can be seen from the plot, the earnings appear to grow over time, therefore we can imagine fitting a line to this data to describe its behaviour (see red line below).

```{r, echo=FALSE}
time_jj <- 1:84
quarters <- as.factor(rep(1:4, 21))
fit_jj1 <- lm(as.vector(jj) ~ time_jj)
plot(time_jj, as.vector(jj), type="l", xlab="Quarters", ylab="Quarterly Earnings per Share")
abline(fit_jj1, col = "red")
```

Although the line captures a part of the behaviour, it is quite clear that the trend of the time series is not linear. It could therefore be more appropriate to define another function of time to describe it and, consequently, we add a quadratic term of time to obtain the following fit.

```{r, echo=FALSE}
fit_jj2 <- gam(as.vector(jj) ~ s(time_jj))
plot(time_jj, as.vector(jj), type="l", xlab="Quarters", ylab="Quarterly Earnings per Share")
lines(time_jj, fit_jj2$fitted.values, col = "red")
```

We can see now that the quadratic function of time allows to better fit the observed time series and closely follow the observations. However, there still appears to be a pattern in the data that isn't captured by this quadratic model. This pattern appears to be repeated over time: peaks and valleys that seem to occur at regular intervals along the time series. This behaviour is known as *seasonality* which, in this case, can be explained by the effect of a specific quarter on the behaviour of the earnings. Indeed, it is reasonable to assume that the seasons have impacts on different variables measured over time (e.g. temperatures, earnings linked to sales that vary with seasons, etc.). Let us therefore take the quarters as an explanatory variable and add it to the previous quadratic model (see fit below).

```{r, echo=FALSE}
fit_jj3 <- gam(as.vector(jj) ~ quarters + s(time_jj))
plot(time_jj, as.vector(jj), type="l", xlab="Quarters", ylab="Quarterly Earnings per Share")
lines(time_jj, fit_jj3$fitted.values, col = "red")
```

This final fit appears to well describe the behaviour of the earnings. Hence, *trend* and *seasonality* are the main features that characterize the deterministic component of a time series. However, as discussed earlier, these deterministic components often don't explain all of the observed time series since there is often a random component characterizing data measured over time. Not considering the latter component can have considerable impacts on the inference procedures (as seen earlier) and it is therefore important to adequately analyse them (see next section).

### The random component (Noise)

From this section onwards we will refer to *time series as being solely the random noise component*. Keeping this in mind, a *time series* is a particular kind of *stochastic process* which, generally speaking, is a collection of random variables indexed by a set of numbers. Not surprisingly, the index of reference for a time series is given by *time* and, consequently, a time series is a collection of random variables indexed (or "measured") over time such as, for example, the daily price of a financial asset or the monthly average temperature in a given location. In terms of notation, a time series is often represented as

 \[\left(X_1, X_2, ..., X_n \right) \;\;\; \text{ or } \;\;\; \left(X_t\right)_{t = 1,...,n}.\]
 
The time index $t$ is contained within either the set of reals, $\mathbb{R}$, or
integers, $\mathbb{N}$. When $t \in \mathbb{R}$, the time series becomes a
*continuous-time* stochastic process such a Brownian motion, a model used to
represent the random movement of particles within a suspended liquid or gas. However, within this book, we will limit ourselves to the cases where $t \in \mathbb{N}$, better known as *discrete-time* processes. *Discrete-time* processes are measured sequentially at fixed
and equally spaced intervals in time. This implies that we will uphold two general assumptions for the time series considered in this book:

1. $t$ is not random, e.g. the time at which each observation is measured is known, and
2. the time between two consecutive observations is constant. 

This book will also focus on certain representations of time series based on parametric probabilistic models. For example, one of the fundamental probability models used in time series analysis is called the *white noise* model and is defined as

\[X_t \mathop \sim \limits^{iid} N(0, \sigma^2).\]

This statement simply means that $(X_t)$ is normally distributed and independent over time. Ideally, this is the type of process that we would want to observe once we have performed a statistical modelling procedure. However, despite it appearing to be an excessively simple model to be considered for time series, it is actually a crucial component to construct a wide range of more complex time series models (see Chapter 2). Indeed, unlike the white noise process, time series are typically *not* independent over time. For example, if we suppose that the temperature in State College is unusually low on a given dat, then it is reasonable to assume that temperature the day after will also be low.

With this in mind, let us present the basic parametric models that are used to build even more complex models to describe and predict the behaviour of a time series.

## Basic Time Series Models {#basicmodels}

In this section, we introduce some simple time series models that consitute the building blocks for the more complex and flexible classes of time series commonly used in practice. Before doing so it is useful to define $\Omega_t$ as all the information available up to time
$t-1$, i.e.

\[\Omega_t = \left(X_{t-1}, X_{t-2}, ..., X_0 \right).\]

As we will see further on, this compact notation is quite useful.

### White Noise {#wn}

As we saw earlier, the white noise model is the building block for most time series models and, to better specify the notation used throughout this book, this model is defined as

\[{W_t}\mathop \sim \limits^{iid} N\left( {0,\sigma _w^2} \right).\]

This definition implies that:

1. $\mathbb{E}[W_t | \Omega_t] = 0$ for all $t$,
2. $\text{cov}\left(W_t, W_{t-h} \right) = \boldsymbol{1}_{h = 0} \; \sigma^2$ for
all $t, h$.

More specifically, $h \in \mathbb{N}^+$ is the time difference between lagged variables. Therefore, in this process there is an absence of temporal (or serial) correlation and it is homoskedastic (i.e. it has a constant variance). Going into further details, white noise can be categorzied into two sorts of processes: *weak* and *strong*. The process $(W_t)$ is
a *weak* white noise if

1. $\mathbb{E}[W_t] = 0$ for all $t$,
2. $\text{var}\left(W_t\right) = \sigma_w^2$ for all $t$,
3. $\text{cov} \left(W_t, W_{t-h}\right) = 0$ for all $t$ and for all $h \neq 0$.

Note that this definition does not imply that $W_t$ and $W_{t-h}$ are independent (for $h \neq 0$) but simply uncorrelated. However, the notion of independence is used to define a *strong* white noise as

1. $\mathbb{E}[W_t] = 0$ and $\text{var}(W_t) = \sigma^2 < \infty$, for all $t$,
2. $F(W_t) = F(W_{t-h})$ for all $t,h$ (where $F(W_t)$ denotes the marginal distribution of $W_t$),
3. $W_t$ and $W_{t-h}$ are independent for all $t$ and for all $h \neq 0$.

It is clear from these definitions that if a process is a strong white noise it is also a weak white noise. However, the converse is not true as shown in the following example:

```{example, label="weaknotstrong"}

Let $Y_t \mathop \sim F_{t+2}$, where $F_{t+2}$ denotes
a Student distribution with $t+2$ degrees of freedom. Assuming the 
sequence $(Y_1, \ldots, Y_n)$ to be independent, we 
let $X_t = \sqrt{\frac{t}{t+2}} Y_t$. Then, the process $(X_t)$ is obviously
not a strong white noise as the distribution of $X_t$ changes with $t$. However
this process is a weak white noise since we have:

- $\mathbb{E}[X_t] = \sqrt{\frac{t}{t+2}} \mathbb{E}[Y_t] = 0$ for all $t$.
- $\text{var}(X_t) = \frac{t}{t+2} \text{var}(Y_t) = \frac{t}{t+2} \frac{t+2}{t} = 1$ for all $t$.
- $\text{cov}(X_t, X_{t+h}) = 0$ (by independence), for all $t$, and for all $h \neq 0$.

```

This distinction is therefore important and will be extremely relevant when discussing the concept of "stationarity" further on in this book. In general, the white noise model is assumed to be Gaussian in many practical cases and the code below presents an example of how to simulate a Gaussian white noise process.

```{r example_WN, fig.height = 4, fig.width = 7, cache = TRUE}
n = 1000                               # process length
sigma2 = 1                             # process variance
Xt = gen_gts(n, WN(sigma2 = sigma2))
plot(Xt)
```

This model can be found in different applied settings and is often accompanied by some of the models presented in the following paragraphs.


### Random Walk {#rw}

The term *random walk* was first introduced by Karl Pearson in the early
nineteen-hundreds and a wide range of random walk models have been defined over the years. For example, one of the simplest forms of a random walk process can be
explained as follows: suppose that you are walking on campus and your
next step can either be to your left, your right, forward or backward
(each with equal probability). Two realizations of such processes are
represented below:

```{r RW2d, fig.height = 5, fig.width = 5.5, cache = TRUE, fig.align='center'}
set.seed(5)
RW2dimension(steps = 10^2)
RW2dimension(steps = 10^4)
```

Such processes inspired Karl Pearson's famous quote that

>
> "*the most likely place to find a drunken walker is somewhere near his starting point.*"
> 

Empirical evidence of this phenomenon is not too hard to find on a Friday or Saturday night. In this text, we only consider one very specific form of random walk, namely the Gaussian random walk which can be defined as:

$$X_t = X_{t-1} + W_t,$$

where $W_t$ is a Gaussian white noise process with initial condition $X_0 = c$ (typically $c = 0$.) This process can be expressed differently by *backsubstitution* as follows:

\[\begin{aligned}
  {X_t} &= {X_{t - 1}} + {W_t} \\
   &= \left( {{X_{t - 2}} + {W_{t - 1}}} \right) + {W_t} \\
   &= \vdots \\
  {X_t} &= \sum\limits_{i = 1}^t {{W_i}} + X_0 =  \sum\limits_{i = 1}^t {{W_i}} + c \\ 
\end{aligned} \]

A random variable following a random walk can therefore be expressed as the cumulated sum of all the random variables that precede it. The code below presents an example of how to simulate a such process.

```{r example_RW, fig.height = 4, fig.width = 7, cache=TRUE}
n = 1000                               # process length
gamma2 = 1                             # innovation variance
Xt = gen_gts(n, RW(gamma2 = gamma2))
plot(Xt)
```

The random walk model is often used to explain phenomena in many different areas one of which is finance where stock prices follow these kind of processes.


### First-Order Autoregressive Model {#ar1}

A first-order autoregressive model or AR(1) is a generalization of both
the white noise and the random walk processes which are both special
cases of an AR(1). A (Gaussian) AR(1) process can be defined as

\[{X_t} = {\phi}{X_{t - 1}} + {W_t},\]

where $W_t$ is a Gaussian white noise. Clearly, an AR(1) with $\phi = 0$ is
a Gaussian white noise and when $\phi = 1$ the process becomes a random walk.

```{remark, label="ar1realizations"}
An AR(1) is in fact a linear combination of past realisations of
a white noise $W_t$ process. Indeed, we have

\[\begin{aligned}
 {X_t} &= {\phi_t}{X_{t - 1}} + {W_t} 
   = {\phi}\left( {{\phi}{X_{t - 2}} + {W_{t - 1}}} \right) + {W_t} \\
   &= \phi^2{X_{t - 2}} + {\phi}{W_{t - 1}} + {W_t} 
   = {\phi^t}{X_0} + \sum\limits_{i = 0}^{t - 1} {\phi^i{W_{t - i}}}.
\end{aligned}\]

Under the assumption of infinite past (i.e. $t \in \mathbb{Z}$) and $|\phi| < 1$,
we obtain

\[X_t = \sum\limits_{i = 0}^{\infty} {\phi^i {W_{t - i}}},\]

since $\operatorname{lim}_{i \to \infty} \; {\phi^i}{X_{t-i}} = 0$.
```

From the conclusion of the above the remark, you may have noticed how we assume that the considered time series have zero expectation. The following remark justifies this assumption.

```{remark, label="ar1mean"}
We generally assume that an AR(1), as well as other time series
models, have zero mean. The reason for this assumption is only to simplfy the
notation but it is easy to consider, for example, an AR(1) process around an
arbitrary mean $\mu$, i.e.

\[\left(X_t - \mu\right) = \phi \left(X_{t-1} - \mu \right) + W_t,\]

which is of course equivalent to

\[X_t = \left(1 - \phi \right) \mu + \phi X_{t-1} + W_t.\]

Thus, we will generally only work with zero mean processes since adding means
is simple.
```

As for the previously presented models, we provide the code that gives an example of how an AR(1) can be simulated.

```{r example_AR1, fig.height = 4, fig.width = 7, cache=TRUE}
n = 1000                              # process length
phi = 0.5                             # phi parameter
sigma2 = 1                            # innovation variance
Xt = gen_gts(n, AR1(phi = phi, sigma2 = sigma2))
plot(Xt)
```

The AR(1) model is one of the most popular and commonly used models in many practical settings going from biology where it is used to explain the evolution of gene expressions to economics where it is used to model macroeconomic trends.


### Moving Average Process of Order 1 {#ma1}

As seen in the previous example, an AR(1) can be expressed as a linear
combination of all past observations of the white noise process $(W_t)$. In a similar manner we can (in some sense) describe the moving average process of order 1 or MA(1) as a "truncated"
version of an AR(1). This model is defined as

\begin{equation} 
  X_t = \theta W_{t-1} + W_t,
\end{equation}
 
where (again) $W_t$ denotes a Gaussian white noise process. As we will see further on, as for the AR(1) model, this model can also be represented as a linear combination of past observations but it has different characteristics which can capture different types of dynamics in various practical cases.

An example on how to generate an MA(1) is given below:

```{r example_MA1, fig.height = 4, fig.width = 7, cache=TRUE}
n = 1000                              # process length
sigma2 = 1                            # innovation variance
theta = 0.5                           # theta parameter
Xt = gen_gts(n, MA1(theta = theta, sigma2 = sigma2))
plot(Xt)
```

The use of this model is widespread, especially combined with the AR(1) model, and can be found in fields such as engineering where it is often used for signal processing.


### Linear Drift {#drift}

A linear drift is a very simple deterministic time series model which can be
expressed as 

\[X_t = X_{t-1} + \omega, \]

where $\omega$ is a constant and with the initial condition $X_0 = c$, where $c$ is an
arbitrary constant (typically $c = 0$). This process can be expressed in a more
familiar form as follows:

\[
  {X_t} = {X_{t - 1}} + \omega 
   = \left( {{X_{t - 2}} + \omega} \right) + \omega 
   = t{\omega} + c  \]

Therefore, a (linear) drift corresponds to a simple linear model with slope $\omega$ and intercept $c$.

```{remark, label="drift"}
You may argue that the definition of this model is not useful since it constitutes a simple linear model. However this model is often accompanied by other time series models (such as the ones presented earlier) and its estimation can be greatly improved when considered in conjunction with the other models.
```

Given its simple form, a linear drift can simply be generated using the code below:

```{r example_Drift, fig.height = 4, fig.width = 7, cache=TRUE}
n = 100                               # process length
omega = 0.5                           # slope parameter
Xt = gen_gts(n, DR(omega = omega))
plot(Xt)
```

This time series model is widely used in different areas of signal analysis where mechanical systems and measuring devices can be characterized by this type of behaviour.


## Composite Stochastic Processes {#lts}

In the previous paragraphs we defined and briefly discussed the basic time series models that can individually be used to describe and predict a wide range of phenomena in a variety of fields of application. However, their capability of capturing and explaining the different behaviours of phenomena through time increases considerably when they are combined to form so-called *composite models* (or composite processes). A composite (stochastic) process can be defined as the sum of underlying (or latent) time series models and in the rest of this book we will use the term *latent time series models* to refer to these kinds of models. A simple example of such a model is given by

\[\begin{aligned}
Y_t &= Y_{t-1} + W_t + \delta\\
X_t &= Y_t + Z_t,
\end{aligned}\]

where $W_t$ and $Z_t$ are two independent Gaussian white noise processes. 
This model is often used as a first basis to approximate the number of
individuals in the context ecological population dynamics. 
For example, suppose we want to study the population of Chamois in the Swiss Alps.
Let $Y_t$ denote the "true" number of individuals in this population at time $t$.
It is reasonable to assume that the number of individuals at time $t$ ($Y_t$) is (approximately) the population at the previous time $t-1$ (e.g the previous year) plus a random variation and a drift. This random variation is due to the natural randomness in ecological population
dynamics and reflects changes such as the number of predators, the abundance
of food, or weather conditions.
On the other hand, ecological *drift* is often of particular interest for ecologists as 
it can be used to determine the "long" term trends of the population 
(e.g. if the population is increasing, decreasing, or stable).
Of course, $Y_t$ (the number of individauls) is typically unknown and we observe
a noisy version of it, denoted as $X_t$. 
This process corresponds to the true population plus a measurement error since
some individuals may not be observed while others may have been counted several
times.
Interestingly, this process can clearly be expressed as a
*latent time series model* (or composite stochastic process) as follows:

\[\begin{aligned}
R_t &= R_{t-1} + W_t \\
S_t &= \delta t \\
X_t &= R_t + S_t + Z_t,
\end{aligned}\]

where $R_t$, $S_t$ and $Z_t$ denote, respectively, a random walk,
a drift, and a white noise. The code below can be used to simulate such data:

```{r example_composite, fig.height = 6, fig.width = 7, cache=TRUE}
n = 1000                                # process length
delta = 0.005                           # delta parameter (drift)
sigma2 = 10                             # variance parameter (white noise)
gamma2 = 0.1                            # innovation variance (random walk)
model = WN(sigma2 = sigma2) + RW(gamma2 = gamma2) + DR(omega = delta)
Xt = gen_lts(n, model)
plot(Xt)
```

In the above graph, the first three plots represent the latent (unobserved)
processes (i.e. white noise, random walk, and drift) and the last one represents
the sum of the three (i.e. $(X_t)$).

Let us consider a real example where these latent processes are useful to
describe (and predict) the behavior of economic variables such as Personal 
Saving Rates (PSR). A process that is used for these settings is the 
"random-walk-plus-noise" model, meaning that the data can be explained by a 
random walk process in addition to which we observe some other process (e.g. 
a white noise model, an autoregressive model such as an AR(1), etc.). The PSR 
taken from the Federal Reserve of St. Louis from January 1, 1959, to  May 1,
2015, is presented in the following plot:

```{r example_PSR, fig.height = 4, fig.width = 7, cache=TRUE}
# Load savingrt dataset
data("savingrt")
# Simulate based on data
savingrt = gts(as.vector(savingrt), start = 1959, freq = 12, unit_ts = "%", 
            name_ts = "Saving Rates", data_name = "US Personal Saving Rates")
# Plot savingrt simulation
plot(savingrt)
```

It can be observed that the mean of this process seems to vary over time,
suggesting that a random walk can indeed be considered as a possible model
to explain this data. In addition, aside from some "spikes" and occasional 
sudden changes, the observations appear to gradually change from one time point
to the other, suggesting that some other form of dependence between them could
exist.
